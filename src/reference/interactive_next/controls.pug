extends ./page.pug

block reference
    p Controls are the constructs by which users can give input to your game. They exist in scenes and have a free-form set of properties that can be used to modify their behavior or appearance.

    p The standard set of custom controls is built upon #[a(href='https://preactjs.com/') Preact], a super lightweight framework that takes care of the dirty work for you. The controls are written in #[a(href='https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html') TypeScript], a superset of JavaScript which gives you the option of adding type annotations to your code. We encourage you to use TypeScript's features if you're comfortable with it or feeling intrepid, but for simplicity's sake examples here will leave out type annotations.

    .alert.alert-info If you haven't already, #[a(href='/reference/interactive_next/index.html#quickstart') create a new project] and follow along with this guide!

    h2#but-rly But Really, What is a Control?

    p When thinking about controls, it's important to remember that there are two consumers: the web frontend as seen by viewers and the Interactive Studio as seen by other developers and some streamers. You are free to only focus on the viewers if you don't need to use the Studio and don't intend to share your integration with other developers. But, keeping this duality in mind is important for understanding the considerations around which controls are designed.

    p In the Custom Control framework, an Interactive control is "just" a class, that happens to be decorated with #[code @Mixer.Control]. The decorator registers the class internally and it is also examined by the #[code miix] command line tool to allow the control to be edited and placed in the Studio. We also provide a useful base component, #[a(href='https://github.com/mixer/interactive-launchpad/blob/master/src/alchemy/preact/Control.tsx'): code &lt;PreactControl /&gt;].

    +highlightFile('javascript', 'reference/interactive_next/controls/basic.jsx')

    p After you create your custom control, you should pass it into the #[a(href='https://github.com/mixer/interactive-launchpad/blob/e6af46a9a78cbd671bb8844764f0839f76c4708f/src/index.tsx#L13'): code register()] function.

    +highlightFile('javascript', 'reference/interactive_next/controls/basic-register.jsx')

    h2#inputs Inputs

    .alert.alert-info If you don't intend to allow your integration to be editable in the studio, you can skip this section entirely.

    p Inputs can be defined on scenes and controls. These are class properties that are settable from the GUI of the Studio, and they must be decorated with #[code @Mixer.Input] decorator. Input types are restricted to what the GUI is able to provide.

    p All JavaScript primitive types&mdash;numbers, strings, booleans&mdash;are able to be provided and can be inferred automatically. For other types, you must specify them manually. You can find a full list of available input kinds #[a(href='https://github.com/mixer/miix-std/blob/6ad36f167fef3a641273858aec6aba5366e40fd5/src/decoration.ts#L106-L133') here]. For example:

    +highlightFile('javascript', 'reference/interactive_next/controls/hello-inputs.jsx')

    p From your game client, you can set properties that #[i aren't] statically-defined inputs. If you do, you can access them by calling #[code this.control.get('myCustomProperty')] anywhere in your class.

    h2#styling-and-positioning Styling &amp; Positioning

    p The custom control framework provides a simple, effective means to add CSS styles and classes to your Preact components. On top of this, there are two layout engines that control where exactly controls are positioned. The Interactive Studio's editing experience is built to these layout engines, and if you're curious to take a look at them you can find the source #[a(href='https://github.com/mixer/interactive-launchpad/blob/master/src/alchemy/preact/Layout.tsx') here].

    h3#layout Layout

    p The important part is that whatever styles the layout engine chooses for a control, it will be passed into the control and accessible in #[code this.props.style] within the class. You then, generally, want to pass these styles into a wrapper element around your content. Let's modify our example to do that:

    +highlightFile('javascript', 'reference/interactive_next/controls/style-example-01.jsx')

    h3#static-styles Static Styles

    p CSS can be written in plain stylesheets which are included in your control bundle. In the launchpad project, you'll see that there is a #[a(href='https://github.com/mixer/interactive-launchpad/blob/master/src/style.scss'): code style.scss] file that serves as an entry point, and imports other stylesheets that contain rules for buttons and joysticks.

    p If you haven't used CSS before, check out Mozilla's #[a(href='https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS') Introduction to CSS].

    p If you know your way around already, you'll notice that the stylesheets are written in #[a(href='http://sass-lang.com/') Sass]. Sass is a preprocessor that adds useful new features on top of CSS, which you can take advantage of if you'd like to.

    h3#styles-in-javascript Styles in JavaScript

    p Often, you'll want to programmatically apply styles based on some JavaScript state, like in the example in the #[a(href='#layout') Layout] section above. In that example, we created an inline style rule manually, but doing this for lots of rules becomes ugly and burdensome.

    p We provide a simple way to create styles from JavaScript objecting using the #[a(href='https://github.com/mixer/interactive-launchpad/blob/master/src/alchemy/Style.tsx'): code RuleSet] class. This provides a simple, convenient way to translate JavaScript objects into CSS properties. Let's make some CSS:

    +highlightFile('javascript', 'reference/interactive_next/controls/style-example-02.jsx')

    p You can combine sets of rules together. This is quite helpful if you want to add your own styles to what's inherited from the layout engine in #[code this.props.style]. Say we wanted to apply that #[code color] CSS rule to the #[em entire] container...

    +highlightFile('javascript', 'reference/interactive_next/controls/style-example-03.jsx')

    h3#conditional-classes Conditional Classes

    p We also provide a helper to conditionally apply classes to an element. Let's make the button have the class #[code is-awesome] only when the input #[code awesome] is true.

    +highlightFile('javascript', 'reference/interactive_next/controls/style-example-04.jsx')

    h2#giving-input Giving Input

    p Control input events are also quite free-form. The Interactive server attaches special logic to certain actions, such as creating Spark transactions on buttons with a cost, but you're free to do pretty much whatever you want here.

    p Input is given by calling #[code this.control.giveInput] inside the class. It takes an object which must have an #[code event] property, and can contain arbitrary other data. Using our previous HelloWorldControl example, let's turn that into a button that sends an event with the viewer's username whenever they press it:

    +highlightFile('javascript', 'reference/interactive_next/controls/hello-give-input.jsx')

    h2#custom-scenes Custom Scenes

    p The launchpad provides a #[a(href='https://github.com/mixer/interactive-launchpad/blob/master/src/alchemy/preact/Scene.tsx') basic scene] out of the box, but you are free to add your own scenes, or customize or replace it!

    p Say you had some specific scene, the #[code leaderboard], for which you wanted to have some scene-level logic or styling applied. Like controls, scenes are decorated with the #[code @Mixer.Scene] decorator. There can be one scene defined as the default, and other scene classes that can be used instead for specific scene names.

    p Let's define that leaderboard scene. We'll extend the default scene and add a title over our controls:

    +highlightFile('javascript', 'reference/interactive_next/controls/scene-01.jsx')

    p Like controls, you need to pass it into the #[code register()] function:

    +highlightFile('javascript', 'reference/interactive_next/controls/scene-register.jsx')

    p And that's it! Whenever the #[code leaderboard] scene is registered, it'll use your custom class and show #[code And the winners are...].

    p Like controls, you can also define and access #[code @Mixer.Input] properties on scenes.
