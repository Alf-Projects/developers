extends ./page.pug

block title
    | Controls | Interactive Reference | Mixer Developers

block reference
    h1 Controls

    p Controls are the constructs by which users can give input to your game. They exist in scenes and have a free-form set of properties that can be used to modify their behavior or appearance.

    p The standard set of custom controls is built upon #[a(href='https://preactjs.com/') Preact], a super lightweight framework that takes care of the dirty work for you. The controls are written in #[a(href='https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html') TypeScript], a superset of JavaScript which gives you the option of adding type annotations to your code. We encourage you to use TypeScript's features if you're comfortable with it or feeling intrepid, but for simplicity's sake examples here will leave out type annotations.

    h2#but-rly But Really, What is a Control?

    p When thinking about controls, it's important to remember that there are two consumers: the web frontend as seen by viewers and the Interactive Studio as seen by other developers and some streamers. You are free to only focus on the viewers if you don't need to use the Studio and don't intend to share your integration with other developers. But, keeping this duality in mind is important for understanding the considerations around which controls are designed.

    p In the Custom Control framework, an Interactive control is "just" a class, that happens to be decorated with #[code @Mixer.Control]. The decorator registers the class internally and it is also examined by the #[code miix] command line tool to allow the control to be edited and placed in the Studio. We also provide a useful base component, #[a(href='https://github.com/mixer/interactive-launchpad/blob/master/src/alchemy/preact/Control.tsx'): code &lt;PreactControl /&gt;].

    +highlightFile('javascript', 'reference/interactive_next/controls/basic.jsx')

    p After you create your custom control, you should pass it into the #[a(href='https://github.com/mixer/interactive-launchpad/blob/e6af46a9a78cbd671bb8844764f0839f76c4708f/src/index.tsx#L13'): code register()] function.

    +highlightFile('javascript', 'reference/interactive_next/controls/basic-register.jsx')

    h2#inputs Inputs

    .alert.alert-info If you don't intend to allow your integration to be editable in the studio, you can skip this section entirely.

    p Inputs can be defined on scenes and controls. These are class properties that are settable from the GUI of the Studio, and they must be decorated with #[code @Mixer.Input] decorator. Input types are restricted to what the GUI is able to provide.

    p All JavaScript primitive types&mdash;numbers, strings, booleans&mdash;are able to be provided and can be inferred automatically. For other types, you must specify them manually. You can find a full list of available input kinds #[a(href='https://github.com/mixer/miix-std/blob/6ad36f167fef3a641273858aec6aba5366e40fd5/src/decoration.ts#L106-L133') here]. For example:

    +highlightFile('javascript', 'reference/interactive_next/controls/hello-inputs.jsx')

    p From your game client, you can set properties that #[i aren't] statically-defined inputs. If you do, you can access them by calling #[code this.control.get('myCustomProperty')] anywhere in your class.

    h2#styling-and-positioning Styling &amp; Positioning

    p The custom control framework provides a simple, effective means to add CSS styles and classes to your Preact components. On top of this, there are two layout engines that control where exactly controls are positioned. The Interactive Studio's editing experience is built to these layout engines, and if you're curious to take a look at them you can find the source #[a(href='https://github.com/mixer/interactive-launchpad/blob/master/src/alchemy/preact/Layout.tsx') here].

    h3#layout Layout

    p The important part is that whatever styles the layout engine chooses for a control, it will be passed into the control and accessible in #[code this.props.style] within the class. You then, generally, want to pass these styles into a wrapper element around your content. Let's modify our example to do that:

    +highlightFile('javascript', 'reference/interactive_next/controls/style-example-01.jsx')

    h3#working-with-css Working with CSS

    p CSS is compiled using the #[a(href='https://github.com/mixer/interactive-launchpad/blob/master/src/alchemy/Style.tsx'): code RuleSet] class. This provides a simple, convenient way to translate JavaScript objects into CSS properties. Let's make some CSS:

    +highlightFile('javascript', 'reference/interactive_next/controls/style-example-02.jsx')

    p You can combine sets of rules together. This is quite helpful if you want to add your own styles to what's inherited from the layout engine in #[code this.props.style]. Say we wanted to apply that #[code color] CSS rule to the #[em entire] container...

    +highlightFile('javascript', 'reference/interactive_next/controls/style-example-03.jsx')

    h3#conditional-classes Conditional Classes

    p We also provide a helper to conditionally apply classes to an element. Let's make the button have the class #[code is-awesome] only when the input #[code awesome] is true.

    +highlightFile('javascript', 'reference/interactive_next/controls/style-example-04.jsx')

    h2#giving-input Giving Input

    p Control input events are also quite free-form. The Interactive server attaches special logic to certain actions, such as creating Spark transactions on buttons with a cost, but you're free to do pretty much whatever you want here.

    p Input is given by calling #[code this.control.giveInput] inside the class. It takes an object which must have an #[code event] property, and can contain arbitrary other data. Using our previous HelloWorldControl example, let's turn that into a button that sends an event with the viewer's username whenever they press it:

    +highlightFile('javascript', 'reference/interactive_next/controls/hello-give-input.jsx')
